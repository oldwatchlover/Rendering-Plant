
# _scan_ - A Scanline Algorithm 3D Renderer

Actually, it's not a full scanline algorithm (_Watkins, Newell-Newell-Sancha, or
REYES A-buffer, ..._) but more properly a scanline front end for a ray tracing
back end.

### ALGORITHM

A scanline algorithm sorts all polygons in screen space `y`, putting them in 
"buckets", one bucket per scanline they touch. As each scanline is processed, 
the triangles are further sorted in screen space `x` (creating _edge pairs_ 
that span a range of pixels) so that for each screen pixel, the list of polygons 
that are candidates to illuminate that pixel is vastly reduced (and easily retrieved).

Some scanline algorithms further sort in screen space `z` per pixel to determine which
polygon (or polygons) cover a specific screen pixel. This implementation does not 
do that - rather it uses the ray tracing method to calculate the screen pixel 
value<sup>[1](#screenprojmath)</sup>.

As it processes across each edge-pair on a given scanline, it casts a camera
ray into the polygons that touch that pixel. This is a very simple and fairly
powerful accleration when compared to a classic Whitted-style ray tracing 
algorithm - each pixel is typically covered by only a handful of polygons 
rather than the thousands (or more!) that might exist in the scene and would need 
to be tested for intersection with a brute force algorithm.

Another benefit of using the ray tracing method per pixel is that we can use
it's more sophisticated recursive shading model, casting secondary rays into
the scene for shadows, reflection, and refracted transparency.

(and for this implementation, we can share lots of the code by linking with `libray.a`)

<a name="screenprojmath"><sup>1</sup></a> For this technique to work, the math calculating the polygon position in screen space must match _exactly_ the perspective effect generated by the ray tracing pinhole camera model so that while processing _edge pairs_ in screen space we are sure to have the correct candidates to trace with the ray tracer and positioned correctly with sub-pixel accuracy for shading. This is much harder than it sounds and that it all works so well here is one of my proudest accomplishments with **_Rendering Plant_** and these sample renderers. `#humblebrag`


### IMPLEMENTATION LIMITATIONS

    - it is a polygonal renderer. Only triangles (or input that can be broken up
      into triangles). It is built with my librp.a framework, which will
      approximate spheres with polygonal data automatically.

    - it has all the limitations of "moray" (libray.a), with respect to shading
      and texturing.

This renderer implements and uses two of the generic scene state flags:

    RENDER01        disable clipping (useful for debugging or performance optimization)
    RENDER02        outline all triangles with a red border (useful for debugging)

### IDEAS FOR FUTURE WORK

Some ideas for improvements:

    - The polygonal approximation of spheres is a tesselated icosahedron with a fixed
      subdivision. This could be too many polygons (or too few) depending on the 
      distance between the camera and the sphere (and the size of the sphere). The
      tesselation could be dynamic based on these factors.

    - Other implicit surfaces (and tesselations) could be implemented.

    - The scanline edge processing is not as efficient as it could be. Some obvious
      improvements:

        - The original Watkins scanline algorithm was designed to save memory of
          the "active" geometry being rendered... Like a lot of algorithms, we are
          much more casual with using more memory than we were in the 1970's :-)
          Nevertheless, rather than putting a triangle into each bucket it touches,
          we could just put it into the first bucket it touches, and then manipulate
          the "current" bucket from scanline to scanline, adding new triangles and removing
          old triangles as they enter/leave the screen y space. If we were going
          to be rendering very large poly counts, this would be a good idea.

        - Right now, the extant of the triangles inserted into the bucket list uses
          the 2D screen space bounding box of that triangle. This is not as tight as
          it could be. More code, and you could use a DDA-style algorithm to "walk"
          the edges, creating a tighter edgepair. I did not do that in this implementation
          becuase this is really just a demo of integrating another type of renderer
          with the framework, not a production level renderer. The benefit of this
          improvement also decreases as triangles get small (and they usually are quite
          small, except for sweeping ground planes or very large flat surfaces).




