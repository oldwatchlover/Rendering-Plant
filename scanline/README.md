
A scanline algorithm 3D render.


Actually, it's not a full scanline algorithm (_Watkins, Newell-Newell-Sancha, or
REYES A-buffer, ..._) but more properly a scanline front end for a ray tracing
back end.

A scanline algorithm sorts all polygons in screen space `y`, putting them in 
"buckets", one bucket per scanline. As each scanline is processed, the triangles
are further sorted in screen space `x` (creating _edge pairs_ that span a range of
pixels) so that for each screen pixel, the list of polygons that are candidates 
to illuminate that pixel is vastly reduced.

Some scanline algorithms further sort in screen space `z` per pixel to determine which
polygon (or polygons) cover a specific screen pixel. This implementation does not 
do that - rather it uses the ray tracing method to calculate the screen pixel value<sup>[1](#screenprojmath)</sup>.

As it processes across each edge-pair on a given scanline, it casts a camera
ray into the polygons that touch that pixel. This is a very simple and fairly
powerful accleration when compared to a classic Whitted-style ray tracing 
algorithm - each pixel is typically covered by only a handful of polygons 
rather than the thousands (or more!) that might exist in the scene and would need 
to be intersected with a brute force algorithm.

Another benefit of using the ray tracing method per pixel is that we can use
it's more sophisticated recursive shading model, casting secondary rays into
the scene for shadows, reflection, and refracted transparency.

Limitations:

    - it is a polygonal renderer. Only triangles (or input that can be broken up
      into triangles). It is built with my librp.a framework, which will
      approximate spheres with polygonal data automatically.

    - it has all the limitations of "moray" (libray.a), with respect to shading
      and texturing.

This renderer does not support `sphere()` input as implicit surfaces... it calls 
`RPEnableSphereSupport(FALSE);` in main.c. Any sphere primitives in the scene will be automatically
replaced with a polygonal representation of a sphere.

This renderer implements and uses two of the generic scene state flags:

    RENDER01        disable clipping (useful for debugging or performance optimization)
    RENDER02        outline all triangles with a red border (useful for debugging)



<a name="screenprojmath"><sub>1</sub></a> For this technique to work, the math calculating the polygon position in screen space must match _exactly_ the perspective effect generated by the ray tracing pinhole camera model so that while processing _edge pairs_ in screen space we are sure to have the correct candidates to trace with the ray tracer and positioned correctly with sub-pixel accuracy for shading. This is much harder than it sounds and that it all works so well here is one of my proudest accomplishments with **_Rendering Plant_** and these sample renderers. `#humblebrag`
